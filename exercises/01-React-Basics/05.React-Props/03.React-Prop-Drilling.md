# 🕳️ React Prop Drilling

## ❓ What is Prop Drilling?

**Prop Drilling** is when you pass data through multiple nested components, even if only the deepest child actually needs it.

> This usually happens when a top-level component has data that a deeply nested component needs, and the only way to get it there is by passing it through every layer in between.

### 🧾 Example

```jsx
function Parent() {
  const message = "Hello from Parent!";
  return <Child message={message} />;
}

function Child({ message }) {
  return <GrandChild message={message} />;
}

function GrandChild({ message }) {
  return <p>{message}</p>;
}
```

### 📦 Output:
```html
Hello from Parent!
```

Notice how the `Child` doesn't use `message`, but it still has to pass it along. As your app grows, this pattern becomes harder to manage.

---

## ⚠️ Why is Prop Drilling a Problem?

| Problem                     | Description                                                      |
| --------------------------- | ---------------------------------------------------------------- |
| 🔄 Unnecessary Prop Passing | Props are passed through components that don’t need them.        |
| 🧩 Tight Coupling           | Makes components harder to reuse.                                |
| 👀 Poor Readability         | Tracing where a value comes from gets confusing.                 |
| 🛠️ Harder Maintenance      | More components to update when props change.                     |
| 🚀 Not Scalable             | This gets worse in large applications with deep component trees. |

---

## ✅ How to Avoid Prop Drilling

### 1️⃣ Use React’s Context API
The **Context API** lets you share data across the component tree without passing it manually at every level.

> `Note`: We have cover Context API later this is just example, just go through

```jsx
import React, { createContext, useContext } from "react";

const UserContext = createContext();

const App = () => {
  return (
    <UserContext.Provider value="Jane Doe">
      <Parent />
    </UserContext.Provider>
  );
};

const Parent = () => <Child />;
const Child = () => <GrandChild />;
const GrandChild = () => {
  const user = useContext(UserContext);
  return <p>Hello, {user}!</p>;
};
```

#### 🧾 Output:

```html
Hello, Jane Doe!
```

#### ✅ Only the component that needs the data (`GrandChild`) accesses it.

---

### 2️⃣ Create Custom Hooks
You can simplify context usage and improve reusability by creating custom hooks.

```jsx
const UserContext = createContext();
const useUser = () => useContext(UserContext);

const GrandChild = () => {
  const user = useUser();
  return <p>Welcome, {user}!</p>;
};
```

#### 🧠 Benefits:

- Keeps code clean
- Reduces repetition
- Easier to test and refactor

---

### 3️⃣ Use Global State Management (Redux, Zustand, MobX)
For complex apps, using a state management library gives you centralized and scalable data control.

### 🟢 Benefits:

- No prop chaining at all
- Global access to state
- Great for large-scale apps

---

## 🧠 Summary

| Method              | Best Use Case                                 |
| ------------------- | --------------------------------------------- |
| **Context API**     | When a few nested components need shared data |
| **Custom Hooks**    | To clean up and reuse context logic           |
| **Redux / Zustand** | For large apps with complex state needs       |

---

## 🏁 Final Thoughts

Prop Drilling isn’t bad in small doses, but it becomes a problem as your app grows. To keep your code clean and maintainable:
- Use Context API for shared data
- Create custom hooks for logic reuse
- Adopt state management tools for large apps